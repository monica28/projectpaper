\documentclass{mproj}
\usepackage{graphicx}

\usepackage{url}
\usepackage{fancyvrb}
\usepackage[final]{pdfpages}
\usepackage{times}
\usepackage{verbatim}
\usepackage{graphicx}

% for alternative page numbering use the following package
% and see documentation for commands
%\usepackage{fancyheadings}


% other potentially useful packages
%\uspackage{amssymb,amsmath}
%\usepackage{url}
%\usepackage{fancyvrb}
%\usepackage[final]{pdfpages}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Analysis of Security in Mobile Financial Applications}
\author{Monica Gandhi}
\date{9 January 2016}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
abstract goes here.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\educationalconsent

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}

acknowledgements go here.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}\label{intro}

\section{A section}
\subsection{A subsection}
Please note your proposal need not follow the included section headings - this is only a suggested structure. Also add subsections etc as required.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Literature Review}\label{survey}

TODO Use short hard wraps of about 120 lines.  Short lines are easier to maintain in a repository.

In their 5th Annual State of Application Security Report \cite{arxan}, app security company Arxan analysed 126 mobile
health and finance apps from US, UK, Germany and japan and found that 90\% of them had security vulnerabilities. The
research also noticed a disparity in the perceived secuirty of mobile apps by the users and the companies and the
reality of the level of security in their app. More than 90\% of the apps tested were found to have atleast 2 of the top
10 security vulnerability listed by the OWASP project. Also, 59 percent of the Android mobile finance apps tested had at
least three OWASP Mobile Top 10 Risks, whereas 100 percent of the iOS apps tested had at least 3 top risks. The most
prevalent vulnerability was found to be binary protection lacking and insufficinet transport layer protection which may
then lead to application code tampering, reverse-engineering, privacy violations, and data theft. According to the study
conducted by IBM and Ponemon Institute in 2015, 40\% of large companies "aren’t taking the right precautions to secure
the mobile apps they build for customers" \cite{ibm}. The study researched secuirty practices in over 400 companies and
found that 50\% of the organizations devote zero budget towards mobile security. These companies include financial
services, health and pharmaceutical, the public sector, entertainment and retail which are industries that use sensitive
data. The study also says that average of \$34 million is spent by each company annually on mobile app development but
only 5.5 percent is being allocated to mobile apps security.

Android and Apple's iOS are the major mobile platforms in the world right now. A secure mobile OS is necessary for a secure mobile transaction. Android systems are vulnerable to attacks since android applications are self signed and no way to check the safety of the application. 
According to Gartner's report, Android has 84.1\% market share on smartphone sales in first quarter of 2016[access ref].

Mobile financial applications include SMS banking, mobile banking, personal finance applications, mobile money and mobile wallets. All of the mobile financial applications has Mobile payments or m-payments as their main feature. M-payments includes various technologies (NFC, QR Codes, SMS) and stakeholders (financial institutions, mobile network operators, regulators). According to Contini et al\cite{contini2011}, the times when mobiles where used as browser to access internet based banking has changed to " the use of an application-enabled mobile phone as a payment form factor, substituting for a check, cash or a card to eventually create a mobile virtual wallet" \cite{contini2011}. the paper also cites the reasons for the wide acceptance of mobile payment applications as security and convenience. However, security in mobile banking and other financial applications are susceptible to threats and attacks.

Smartphone screens are vulnerable to exposure  through spying ("iSpy"), "fast eavesdropping" or screenshot attack "Screenmilker". These attacks exploit the keystroke animation feature available on smartphones. In \cite{el2015}, the authors try to obtain user credentials by employing a screenshot attack called CaptureMe. As a security measure, usually mobile banking applications require the user to enter their login credentials everytime they open the app unlike in other apps like email, social networks etc where the login info is stored in the application. This repetition in entering login information is exploited where CaptureMe takes screenshots when user is entering username and password. The images are then subjected to OCR analysis to extract the credential information. The authors have evaluated CaptureMe in attack scenario on six different mobile baning applications and the PayPal's mobile banking app. The results showed that the main weakness found was that many applications use user id and password as the only authentication mechanism for their app. They recommend that banking apps shold use multi-factor authentication to preserve their system's integrity. However the one limitation mentioned in this paper is that the Capture Me attack is not possible if the password visibility feature is disabled.

Another vulnerability in Smartphones is information leaking and overcharging. In \cite{stopbanukn}, the authors describe the Bankun attack and propose a countermeasure which helps the user to identify the attack. Bankun (Bank+unistall) is a trojan horse that replaces banking applications with malicious ones to retrieve user financial information. This attack takes place through Smishing which is SMS + Phishing where attackers trick users into installing malicious apps through SMS. For uninstall,  an application requires the permission android.permission.INSTALL\_PACKAGES with the protection level signatureOrSystem which means only the system apps or apps signed with the same key used for platform build can uninstall. So when a third party app tries to unistall other app, PackageInstaller in launched which shows the user with the dialog box requesting confirmation for the uninstall. However the user has no way of recognizing that another app is requsting the uninstall. Sometimes Bankun informs the user of an update in order to get them to unistall the existing banking app to replace it with the new malicious app that looks like the original one. The authors propose a solution to this attack where the user will be informed of the third party app requesting the unistall in the dialog box invoked by the PackageInstaller.

Zhao and Mufic in \cite{zhao} propose a concept called Secure Mobile Wallet. This concept focuses mailny on un-banked users i.e., users in developing nations who do not have a bank account. These customers are the main targets for telecom companies mainly their financial transactions. This Wallet aims to establish a system that provides a simple, secure method for international financial transactions with low fees and quick transfer times. The paper describes two approaches to implement the Wallet for a mobile phone. First is the 'no wallet' approach in which mobile transactions are carried out through SMS or USSD protocol. Users will have to memorize abbreviated SMS keyowrds which the background servers will use to complete the transaction requests or choose options from menu based USSD coomands. Since this approach is not user friendly, the other method is to use Mobile Wallet as a software in the mobile phone. This second method provides complete end-to-end security which includes authentication, authorization, confidentiality and integrity. Mobile Wallet as a software can be implemented in two ways. One is where the application is developed using J2ME and resides in the memory of the phone or a memory card. This method comes with a complete security services but are susceptible to malwares. Hence the paper describes a second and better approach in which Javacard applet is stored in the SIM chip called UICC. This Javacrad application provides additional security which is the native crypto algorithms reent in the chip.Secure Mobile Wallet can also be used with NFC technology for OTC (Over the counter) transactions. It also supports OTA (over the air) transactions based on SMS, GPRS or Intternet. The authors claim that the design is aimed to provide a flexible way of using credit cards or cash by exploiting the security advantages of a Smartcard to guarantee safe data communication.

In \cite{nambiar2004}, Lu et al., describe the different security technologies used in m-commerce and discuss the Public key Infrastructure as a basis for secure mobile technologies. The security challenges in m-commerce invloves the mobile devices, radio interface, network operator infrastucture and the type of m-commerce application. PKI for mobile security involves Public key cryptography. In case of mobile devices, Elliptic curve cryptography algorithms are found to be more suitable because it allows shorter keys which will enable faster computations, lower power consumption, less memory and bandwidth requirements. PKI ivolves digital certificates, certification authorities and other registration authorities.

\subsection{Threats}
He et al\cite{he2015} in their research used blog mining as a research method to analyse various blog discussions on mobile banking application security. To tackle mobile security issues, developers have been producing new security techniques, practices and solutions.  However knowledge about these security risks and solutions are scattered over different white papers, articles, and forum discussions. To provide users with the in-depth knowledge of security issues, the authors have summarized risks and best practices from related discussions using blog mining. A survey conducted by BI Intelligence\cite{businessinsider} found that 31\% of customers from US banks are willing to pay for added security features and 63\% are willing to switch accounts for one with better security features. The blog mining method employed by the researches has a limitation in that the blog discussions were not peer reviewed articles and are simply every user's personal opinions. To mitigate this, the blog mining was combined "with an extensive literature search for a more comprehensive understanding of the topics that are under investigation". The researchers used Google blog search engine with keywords "mobile banking security" and "mobile apps vulnerability" which resulted in 200,000 results. The first 100 records were selected as the data set. NVivo 10 was the tool used for analytics and text mining. The threats identified through this process are malwares like Trojans, rootkits, viruses, threats from third party applications, Phishing, Unencrypted Wi-fi networks and protection against reverse enginerring of the code. The blog mining results also indicated some emerging trends in security enforcement like integrating biometrics in banking apps to improve authentication, integrating intelligent behavioral monitoring and analysis technology with mobile banking apps and deployment of advanced big data analytics technology for fraud detection and behavioral analysis.

NFC (Near field Communication) is a short-range communication protocol which is used nowadays to enable contatcless payments. NFC are exclusively used in ticketing and mobile payments\cite{vermaas}. Google Wallet and ApplePay are two prominent platforms that use NFC payment technology\cite{vermaas}. In his paper, vermaas \cite{vermaas} describes the NFC payment security architecture and presents a set of attack and fraud scenarios. NFC devices face vulnerabilites in all its components. NFC smartphones are susceptible to malwares in form of suspicious apps, relay attacks, theft and skimming. The communication between the phone and the PoS terminal is not encrypted whick makes it vulnerable to eavesdropping. The PoS terminals have external communication channles like NFC reader, card reader and internet connection all of which are vulnerable to malwares which in turn leads to security issues in the NFC payment. The author then listed ten attack scenarios and ranked their likelihood of occurence through expert elicitaion. A total of 39 experts in the field of NFC, RFID technology were used to rank the most likely scenarios. Delay of Service, relay attack and theft were identified as the likely possible scenarios.

The research in \cite{abolghasemi} presents the challenges involved in SMS-based mobile banking and proposes a new protocol for encrypting SMS using GSM positioning system. The authors briefly describe some of the attacks that might happen during sending, receiving and storage of SMS (like spoofing, masquerading attacks, physical security of the SMS centre). The only encryption that takes place during transmission of SMS from sender to receiver is A5 encryption which is “highly vulnerable to mathematical analyses and physical attacks”. The authors propose End2End Encryption (E2EE) model for the SMS where GSM positioning techniques and timestamp parameters are used to generate private key. When the user enters the PIN code to access the mobile application, the mobile Station(MS) sends a location request to Telecommunication control center (TCC). A hash function is used to secure the PIN code. TCC sends three signals and 3 timestamps to the MS through BTSs (usually, positioning systems have 3 BTS). MS responds with 3 signals and 3 timestamps which are sent to TCC’s database. The private key is created using these timestamps and the message is encrypted and attached to the hash function’s output before being sent through SMS. When bank receives message from user, it retrieves key from its database, decrypts the message and hashes the decrypted text. It is compared with the hash file received from user and if it matches, then the banking operations can be carried out. This is only a proposed method, has not been implemented or stimulated.

There are two types of mobile applications - Mobile Web or Native. Mobile web apps are really websites accessed through the mobile's browser. Native apps are developed specific to the mobile platform and are installed through an application store. Mobile OS like iOS and Android provide APIs for encryption and expect the developers to implement the security features in their app. This results in security issues.

(OWASP guidelines not necessary in lit review?)

[[

Open Web Application Security Project is an online community that publishesarticles, methodologies and technologies in web application security. The OWASP application security cheat sheet is used as a reference for identifying vulnerabilities in mobile application in \cite{acharya2015} and \cite{saito2015}. OWASP Mobile Security Project listed the top ten risks in mobile applications\cite{owasp}.
1. Weak server side controls - untrustworthy input to a backend API service due to lack of proper security controls such as patches and updates or secure configurations.

2. Insecure data storage - sensitive data stored on the device with no protection may result in privacy violations and exposure of personal informtion leading to identity theft, fraud, reputation damage. (malware, malicious user)

3. Insufficient Transport layer protection - .

4. Unintended data leakage -  includes vulnerabilities from the OS, frameworks, compiler environment, new hardware, etc. without a developers knowledge (key presses, logging, cache data).

5. Poor authorization and authentication - 

6. Broken cryptography - results from hardcoding cryptographic keys within the application code itselfor using a custom instead of standard cryptographic algorithm.

7. Client side injection - Mobile malware or other malicious apps may perform a binary attack against the presentation layer (HTML; JavaScript; Cascading Style Sheets CSS) or the actual binary of the mobile app's executable. These code injections are executed either by the mobile app's framework or the binary itself at run-time.

8. Untrusted inputs - applications making security decisions through user inputs are susceptible to malware and injection attacks.

9. Improper session handling - developers might invalidate sessions on the mobile app and forget on the server side providing an opportunity for the attackers. Also lack of adequate timeout protection and failure to reset cookies properly may lead to this risk.

10. Lack of Binary protections - hosting code in untrustworthy environment (expand)
E.g. also medical apps privacy policies paper - example of comprehensive study of issue.

]]

\subsection{Case studies}
Cifuentes et al\cite{cifuentes2015} conducted a research and anlyzed the vulnerabilites in mobile health applications according to the standards of OWASP model \cite{owasp}.  Usually, helath data is collected from users through sensors in mobile devices or peripheral devices thorugh bluetooth. These data require high level security for data storage. However mobile Health apps are vulnerable to malware attacks. In the research conducted in [], the mHealth apps were divided into six groups based on fucntionality and ten applications were selected for each group to be tested. The applications were assessed based on level of risk, type of
vulnerability, and type of risk factor according to OWASP 2014. The application software was decompressed and the APK code was analysed and ranked as High, medium and low risk based on the OWASP top 10 list. A total of 60mHealth apps were analysed and 157 vulnerabiites were found. It is also concluded that the "vulnerabilites are triggered due to accepting data from different sources". Some of the vulnerabilites found were due to broken cryptography, client side injection, insufficient transport layer protection and insecure date storage.

Panja et al\cite{panja2013} conducted an experiment to show how a mobile application can be easily tampered with to acquire user information. For their investigation, they chose Chase Mobile Banking application. The analysis includes only a few portions of the code like "Login Activity". First, a network sniffer was used to study the application's traffic. The whole process from logging in to checking account information  to logging out consisted of conversation over encrypted transmission. Next, the source code of the application was examined. The apk file was disassembled and the application\_config.properties file was modified so that the application connects to a different server than the Chase server. When the app was rebuilt and ran through the Android emulator, all login attempts were redirected to the new server. It was easier to obtain the username and password by running a perl script. The ayhtors claim that although there were no security issues in the code, there were problems with how the application was packaged.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Tools for Analysis of Mobile Apps}

There are a number of automated tools available for android code analysis and vulnerabilty testing. QARK (Quick Android Review Kit) is an automated static source code analysis tool designed to recognize potential security vulnerabilities and points of concern for Java-based Android applications\cite{qark}. It is free to use tool that allows testers to locate precise, in-depth explanations of vulnerabilitoes.  The main advantage of QARK over other tools is that it provides  ADB commands for querying content providers, exploiting injection vulnerabilities, identifying insecure data storage vulnerabilities etc. Some of the vulnerabilites that can be recognized using this tool are private keys embedded in source, tapjacking, exported preference activities, improper certificate validation, intents which are vulnerable toeavesdropping or interception. Another tool is Drozer which is a comprehensive security audit and attack framework for android developed by MWR Labs. According to their official documentation, “Drozer allows you to assume the role of an Android app, and to interact with other apps, through Android’s Inter-Process Communication (IPC) mechanism, and the underlying operating system”\cite{drozer}. Drozer runs both in Android emulators and on real devices , so you can perform assessments on devices can be carried out in their production state for better results. Another android vulnerability analysis tool is the AndroBugs framework that helps developers or hackers find potential security vulnerabilities in Android applications. This tool performs functions like finding vulnerabilites, checking code for best practices, checking for dangerous shell commands and check the app's security permission\cite{androbugs}.

Malwares are a serious threat to mobile applications. \cite{chandramohan2012} provides a survey of various techiques udes in detection of malwares in mobile phones. Felt et al \cite{felt2011} categorizes the mobile threats into three types - Malware, personal Spyware and Grayware. Malware is a malicious application which the attacker tricks the user into installing it in their phones and then gains access to the device. Trojans, worms, botnets and viruses are some of the malware that steal or manipulate sensitive data, extract credentials or damage the device. When an attacker gets physical control of the phone and installs malicious software to collect victim's personal information like location or call logs is called a personal spyware. Grayware is the one which companies use to collect user data for user profiling or marketing purposes. Grayware do not cause damage to the users. The paper \cite{chandramohan2011} discusses five types of malware detection techniques. Static analysis is done without executing the application. The application is disassembled into Java source (in case of android) and the source code is reviewed.  For exapmle, DeDexer generated DEX assembly code from application binary , dex2jar to convert DEX files to JAR files. Then tools like FindBugs can be used to analyse the JARsThis technique has been tested with 1100 applications, however it is limited to applications that has small number of permissions or API calls. 

Dynamic analysis is performed by executing the application in an emulator or a virtual machine.  Dynamic analysis tools allow testers to reverse engineer communication protocols and allow malicious messages from the testers to attack server side resources.  TaintDroid is a tool propsed by Enck et al\cite{enck2014} which provides system-wide dynamic taint tracking and analysis of android software. This tool was tested with 30 android applications and 15 of those were found to share user location with advertisers and 7 applications shared phone identifiers with remote servers without user's knowledge. The other tool that incorporates both static and dynamic anlysis offline is the Android Application Sandbox(AASandbox)\cite{blasing2010}. However this approach is not tested against malware that exhibits polymorphic behaviour or code fragment encryption. 

The third technique of malware detection is the Application permission Analysis. Some applications may request unnecessary permissions whereas some may hide permissions from the user. Enck et al \cite{enck2009lightweight} propsed an application certification system called Kirin. When an application is installed, Kirin checks the security configuration of that app against the security policy given to Kirin by the user.  If the application fails this test, it will be unistalled or user will be notified. Kirin was tested with 311 applications and 10 of them were flagged by Kirin. However one limitaion of this is that Kirin only checks the permisiion reuests and doesnot examine how the permissions are used by the app. Each of these techniques have their strengths and weaknesses and users should not rely only on one particular type of analysis for security review. 

[[include Webroot Intelligence Network paper \cite{webroot}]]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Experimental Design}

The applications used for this research consists of UK mobile banking applications in Android shown in Table 1. The APK files of these applications were obtained by using the application \textit{APK Extract \& Backup} which generates APK files of user installed applictions in a device. The experiment involves two phases - the static analysis phase and the reverse engineering phase. 

\begin{table}[ht]
\centering
\resizebox{\textwidth}{!}
%\begin{center}
{\begin{tabular}{ | c | c | c | c | c | c | } 
\hline
No & Application & Version & Company & Filename & Downloaded \\ [0.5ex] 
\hline\hline
1 & Barclays Mobile Banking & 1.37 & Barclays Bank PLC & Barclays.apk \\ 

2 & Bank of Scotland Mobile Bank & 15.0 & Lloyds Bank PLC & BankofScot.apk \\

3 & Lloyds Bank Mobile Banking & 15.0 & Lloyds Bank PLC & LloydsBank.apk \\

4 & Halifax Mobile Banking app & 15.0 & Lloyds Bank PLC & Halifax.apk \\

5 & NatWest & 04.09.0000.52.0 & The Royal Bank of Scotland PLC & Natwest.apk \\  

6 & HSBC Mobile Banking & 1.5.15.0 & HSBC &HSBC.apk \\ 

7 & TSB Mobile Banking & 11.0 & TSB Bank Plc & TSB.apk \\ 

8 & Royal Bank, RBS & 04.10.0000.22.0 & The Royal Bank of Scotland PLC & RBS.apk \\ 

9 & Tesco Bank Mobile Banking &  & Tesco Bank & Tesco.apk \\ 

10 & Mobile Bank UK & 3.15 & Danske Bank & MobileBank.apk \\ 

11 & Personal Banking & 3.9.2 & Santander UK plc & SantanderUK.apk \\ 

12 & Nationwide Banking App & 3.20.28 & Nationwide Building Society &  \\ 

13 & The Co-operative Bank & 2.2.95.64 & CoopBank &  \\ 

14 & J.P. Morgan Mobile & 3.33 & JPMorgan Chase &  \\
\hline
\end{tabular}}
%\end{center}
\end{table}

\section{Phase 1}
\subsection{AndroBugs}

AndroBugs is an open source framework written in Python to help find valid security vulnerabilites in Android apps. The tool is designed for massive analysis and it can be extended to include new features or add vulnerability vectors. Some of the vulnerabilities it checks for include checking if the code is missing best practices, checking dangerous shell commands like "su", collecting information from millions of apps and checking an app’s security protection [ref].  The analysis is done by executing the command \textit{androbugs.exe -f [APK file]}. AndroBugs generates a report after each analysis which contains the following information.
\begin{itemize}
\item Vector title
\item Source code paths
\item Severity level
\item Vector Category
\item Detail Explanations (background knowledge of the vulnerability)
\item Mitigation recommendations
\item Reference research papers or links
\end{itemize}

There are four severity levels for the vulnerabilites. 
\begin{table}[ht]
\centering
\resizebox{\textwidth}{!}
%\begin{center}
{\begin{tabular}{ | c | c | } 
\hline
Severity Level & Description \\ [0.5ex] 
\hline
Critical & Confirmed security vulnerability that should be solved (except for testing code) \\
\hline
Warning & Not sure if this is a security vulnerability. Developers need to manually confirm \\
\hline
Notice & Low priority issue or AndroBugs Framework tries to let you know some additional information \\
\hline
Info & No security issue detected \\
\hline
\end{tabular}}
%\end{center}
\end{table}

The AndroBugs framework implements a number of vulnerability vectors which have been decided after research from more than eight Android security books, previously published papers and research, Android Developer Reference Websites, previously published security vulnerabilities and some technical blogs and articles\cite{}. Some of the vulnerabilities discovered are 
\begin{itemize}
\item World Readable and World Writable
\item ContentProvider Vulnerability and Directory Traversal
\item WebView File Access Vulnerability and Exported Components
\item SSL Vulnerability
\item Implicit Broadcast
\item Dynamically Registered Unprotected BroadcastReceiver
\item Allow Debuggable
\end{itemize}

The vulnerability vectors are grouped in categories such as SSL\_Security, Sensitive\_Information, WebView, Command, Database, Debug, Implicit\_Intent, Hacker and System. Once the APK file of the application is run through the tool, the report is generated as a text file in an automatically created 'Reports' folder. If potential security vulnerabilities are found in the report, then the application is manually decompiled to verify if the vulnerability is valid. 

\subsection{Drozer}

Drozer is another open source security assessment platform developed for Android. It works by allowing the user to assume the role of an Android app and interact with other apps by making use of Android’s Inter-Process Communication (IPC) mechanism. Drozer also helps to remotely exploit Android devices, by building malicious files or web pages that exploit known vulnerabilities. Depending on the permissions granted to the vulnerable app, "drozer can install a full agent, inject a limited agent into the process using a novel technique or spawn a reverse shell"\cite{}. Running Drozer requires a PC (Windows in this experiment) and an Android device or emulator. The software requirements inlude JDK 1.6, Python 2.7 and Android SDK. Following steps are involved in using the tool against applications.

1. The drozer installer is downloaded from its site and run which builds a complete python environment with all the required dependencies. 

2. Install the drozer agent using command \textit{adb install agent.apk}. The drozer agent is launched in the emulator.

3. Set up a suitable port forward so that your PC can connect to a TCP socket opened by the Agent inside the emulator, or on the device. By default, drozer uses port 31415. \textit{ adb forward tcp:31415 tcp:31415}

4. Enable the Embedded server to start the server in the emulator.

5. The server is connected to PC using 
 \begin{Verbatim}[fontsize=\small]
$ C:\drozer\drozer.bat console connect
\end{Verbatim}

The drozer console is a command line environment and provides a wide range of modules for interacting with an Android device to assess its security. For example, the command and output for content provider vulnerability check for a specific app is shown below. 
 \begin{Verbatim}[fontsize=\small]
dz> run scanner.provider.injection -a co.uk.Nationwide.Mobile
Scanning co.uk.Nationwide.Mobile...
Not Vulnerable:
  content://com.google.android.wearable.provider.calendar
  content://com.google.android.wearable.provider.calendar/

Injection in Projection:
  No vulnerabilities found.

Injection in Selection:
  No vulnerabilities found.
\end{Verbatim}

The commands and their description can be found in appendix 2.

\section{Phase 2}

Phase 2 involves manual checking of code through reverse engineering. Since it is difficult to obtain the pure Java code of the application due to code obfuscation, the Dalvik bytecode i.e., the dex file is converted to the Smali format. Converting dex file to smali is called baksmaling and it gives readable code in Smali language. For this experiment, ApkTool is used to retrieve the smali code from the APK file. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}\label{conclusion}

\appendix % first appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{First appendix}

\section{Section of first appendix}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Second appendix}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% it is fine to change the bibliography style if you want
\bibliographystyle{plain}
\bibliography{mproj}
\end{document}
